import { LogLevel } from './constants';
import { Formatter } from './formatter';
import { Transport } from './transports';
/**
 * Logger main class. Use Logger.get() to create a new Logger.
 */
export declare class Logger {
    private static readonly detector;
    /**
     * The name of the current logger. This is derived from the argument in Logger.get().
     */
    readonly name: string;
    /**
     * The package name of the current logger. This is derived from the package.json file of the caller project.
     */
    readonly packageName: string;
    /**
     * The package path of the current logger. This is derived from the location Logger.get() was ran in.
     */
    readonly packagePath: string;
    /**
     * Extra data for this logger. This will be used additionally to the extra data passed in every log call.
     */
    readonly extra: {
        [key: string]: string;
    };
    private constructor();
    /**
     * Logs a message with [[LogLevel]] *ERROR*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    error(log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Logs a message with [[LogLevel]] *WARN*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    warn(log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Logs a message with [[LogLevel]] *INFO*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    info(log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Logs a message with [[LogLevel]] *DEBUG*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    debug(log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Logs a message with [[LogLevel]] *TRACE*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    trace(log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Logs a message.
     *
     * @param level The log level
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     */
    log(level: LogLevel, log: string | Error | (() => string | Error), uniqueMarker?: string, extra?: {
        [key: string]: any;
    }): void;
    /**
     * Creates a new logger instance for the current context.
     *
     * @param forClass A string or a Class for the loggers name
     * @param extra Optional. An object containing additional data that will be appended on every log call
     *
     * @returns A new logger instance
     */
    static get(forClass?: string | Function, extra?: {
        [key: string]: any;
    }): Logger;
    /**
     * Creates a new custom logger instance without running any package detection.
     * The first three arguments can also be functions returning the specified value so they can be changed.
     * The functions will be called for every log-call.
     *
     * @param name The loggers name
     * @param packageName The loggers package name
     * @param packagePath The loggers package path (This should to end with a "." if it's not empty so it looks correct)
     * @param extra Optional. An object containing additional data that will be appended on every log call
     *
     * @returns A new logger instance
     */
    static custom(name: string | (() => string), packageName: string | (() => string), packagePath: string | (() => string), extra?: {
        [key: string]: any;
    }): Logger;
    /**
     * Changes the global formatter.
     * Note that this will affect every transport not explicitly defining their own formatter.
     * If you want to only change the formatter on the default transport use `Logger.getDefaultTransport().setFormatter()`.
     * The formatter must extend the class [[Formatter]].
     * Alternatively `null` can be passed to reset the global formatter to the [[DefaultFormatter]].
     *
     * @param formatter The new global formatter
     */
    static setFormatter(formatter: Formatter): void;
    /**
     * Adds a new transport.
     * Note that the transport will get all logging data from every installed module that uses this logging library.
     * The transport must extend the class [[Transport]].
     *
     * @param transport The transport to be added
     */
    static addTransport(transport: Transport<any>): void;
    /**
     * Returns the default [[ConsoleTransport]] or null if the default transport has been disabled.
     *
     * @returns The default [[ConsoleTransport]]
     */
    static getDefaultTransport(): import("./transports").ConsoleTransport;
    /**
     * Disables the default [[ConsoleTransport]].
     * Note that calling this will affect every installed module that uses this logging library.
     */
    static disableDefaultTransport(): void;
    /**
     * Returns the version major of this package.
     * This is used by @ayana/logger-api to determine compatibility.
     *
     * @returns The version major of this package.
     */
    static getVersionMajor(): number;
}
