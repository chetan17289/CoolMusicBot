"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 - 2019 Ayana Developers <devs@ayana.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path = require("path");
const config_1 = require("./config");
const constants_1 = require("./constants");
const formatter_1 = require("./formatter");
const transports_1 = require("./transports");
const util_1 = require("./util");
/**
 * Logger main class. Use Logger.get() to create a new Logger.
 */
class Logger {
    constructor(name, pkgName, pkgPath, extra) {
        if (typeof name === 'function') {
            Object.defineProperty(this, 'name', {
                get: name,
                configurable: false,
                enumerable: false,
            });
        }
        else {
            Object.defineProperty(this, 'name', {
                value: name,
                writable: false,
                configurable: false,
                enumerable: true,
            });
        }
        if (typeof pkgName === 'function') {
            Object.defineProperty(this, 'packageName', {
                get: pkgName,
                configurable: false,
                enumerable: false,
            });
        }
        else {
            Object.defineProperty(this, 'packageName', {
                value: pkgName,
                writable: false,
                configurable: false,
                enumerable: true,
            });
        }
        if (typeof pkgPath === 'function') {
            Object.defineProperty(this, 'packagePath', {
                get: pkgPath,
                configurable: false,
                enumerable: false,
            });
        }
        else {
            Object.defineProperty(this, 'packagePath', {
                value: pkgPath,
                writable: false,
                configurable: false,
                enumerable: true,
            });
        }
        Object.defineProperty(this, 'extra', {
            value: extra,
            writable: false,
            configurable: false,
            enumerable: false,
        });
    }
    /**
     * Logs a message with [[LogLevel]] *ERROR*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    error(log, uniqueMarker, extra) {
        this.log(constants_1.LogLevel.ERROR, log, uniqueMarker, extra);
    }
    /**
     * Logs a message with [[LogLevel]] *WARN*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    warn(log, uniqueMarker, extra) {
        this.log(constants_1.LogLevel.WARN, log, uniqueMarker, extra);
    }
    /**
     * Logs a message with [[LogLevel]] *INFO*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    info(log, uniqueMarker, extra) {
        this.log(constants_1.LogLevel.INFO, log, uniqueMarker, extra);
    }
    /**
     * Logs a message with [[LogLevel]] *DEBUG*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    debug(log, uniqueMarker, extra) {
        this.log(constants_1.LogLevel.DEBUG, log, uniqueMarker, extra);
    }
    /**
     * Logs a message with [[LogLevel]] *TRACE*
     *
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     *
     * @see Logger#log
     */
    trace(log, uniqueMarker, extra) {
        this.log(constants_1.LogLevel.TRACE, log, uniqueMarker, extra);
    }
    /**
     * Logs a message.
     *
     * @param level The log level
     * @param log The string or error that should be logged. This can also be a function returning a string or an error. The function will only be called if the result is acutally logged
     * @param uniqueMarker Optional. The unique marker for denoting different instances of a class
     * @param extra Optional. An object containing additional data that can be used later on
     */
    log(level, log, uniqueMarker, extra) {
        let meta = null;
        for (const transport of config_1.Config.getInstance().transports) {
            if (meta == null)
                meta = transport.log(this, level, log, uniqueMarker, Object.assign({}, this.extra, extra));
            else
                transport.logMeta(meta);
        }
    }
    /**
     * Creates a new logger instance for the current context.
     *
     * @param forClass A string or a Class for the loggers name
     * @param extra Optional. An object containing additional data that will be appended on every log call
     *
     * @returns A new logger instance
     */
    static get(forClass, extra) {
        let name;
        if (forClass == null || forClass === '')
            name = 'index.js';
        else if (typeof forClass === 'function')
            name = forClass.name;
        else if (typeof forClass === 'string')
            name = forClass;
        else
            throw new Error('Logger.get(): Invalid forClass parameter. Use a string or a named function');
        const callerDirectory = Logger.detector.getCallerDirectory();
        const projectRoot = Logger.detector.getRootOf(callerDirectory);
        const pkg = Logger.detector.getInfo(projectRoot);
        let pkgMain = '';
        if (pkg.loggerBase != null)
            pkgMain = pkg.loggerBase;
        else if (pkg.main != null)
            pkgMain = path.dirname(pkg.main);
        // Project file root. Used as a base to find the package path
        const pkgBase = path.join(projectRoot, pkgMain);
        // Relative path that gets printed in the end
        let pkgPath = path.relative(pkgBase, callerDirectory);
        // Check path starting with . or .. which means it is not a child of the pkgBase directory
        if (pkgPath.startsWith('.'))
            throw new Error('Logger.get(): This file is not in the logger base path for this project');
        pkgPath = pkgPath.replace(path.sep, '.');
        if (pkgPath.length > 0 && name !== 'index.js')
            pkgPath = `${pkgPath}.`;
        if (name === 'index.js')
            name = '';
        return new Logger(name, pkg.name, pkgPath, extra);
    }
    /**
     * Creates a new custom logger instance without running any package detection.
     * The first three arguments can also be functions returning the specified value so they can be changed.
     * The functions will be called for every log-call.
     *
     * @param name The loggers name
     * @param packageName The loggers package name
     * @param packagePath The loggers package path (This should to end with a "." if it's not empty so it looks correct)
     * @param extra Optional. An object containing additional data that will be appended on every log call
     *
     * @returns A new logger instance
     */
    static custom(name, packageName, packagePath, extra) {
        return new Logger(name, packageName, packagePath, extra);
    }
    /**
     * Changes the global formatter.
     * Note that this will affect every transport not explicitly defining their own formatter.
     * If you want to only change the formatter on the default transport use `Logger.getDefaultTransport().setFormatter()`.
     * The formatter must extend the class [[Formatter]].
     * Alternatively `null` can be passed to reset the global formatter to the [[DefaultFormatter]].
     *
     * @param formatter The new global formatter
     */
    static setFormatter(formatter) {
        // Reset to default formatter if null or undefined is given
        if (formatter == null)
            formatter = new formatter_1.DefaultFormatter();
        // Check instance
        if (!(formatter instanceof formatter_1.Formatter))
            throw new Error('Invalid formatter');
        config_1.Config.getInstance().formatter = formatter;
    }
    /**
     * Adds a new transport.
     * Note that the transport will get all logging data from every installed module that uses this logging library.
     * The transport must extend the class [[Transport]].
     *
     * @param transport The transport to be added
     */
    static addTransport(transport) {
        if (transport == null)
            return;
        if (!(transport instanceof transports_1.Transport))
            throw new Error('Invalid transport');
        config_1.Config.getInstance().transports.push(transport);
    }
    /**
     * Returns the default [[ConsoleTransport]] or null if the default transport has been disabled.
     *
     * @returns The default [[ConsoleTransport]]
     */
    static getDefaultTransport() {
        return config_1.Config.getInstance().defaultTransport;
    }
    /**
     * Disables the default [[ConsoleTransport]].
     * Note that calling this will affect every installed module that uses this logging library.
     */
    static disableDefaultTransport() {
        config_1.Config.getInstance().disableDefaultTransport();
    }
    /**
     * Returns the version major of this package.
     * This is used by @ayana/logger-api to determine compatibility.
     *
     * @returns The version major of this package.
     */
    static getVersionMajor() {
        return Number(config_1.Config.getInstance().major);
    }
}
Logger.detector = new util_1.PackageDetector();
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map