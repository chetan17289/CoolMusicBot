"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 - 2019 Ayana Developers <devs@ayana.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const config_1 = require("../config");
const constants_1 = require("../constants");
const formatter_1 = require("../formatter");
class Transport {
    constructor(options) {
        this.knownLoggers = new Map();
        this.options = {};
        this.options = Object.assign({}, (options || {}));
        this.setLevel(options.level);
        this.setFormatter(options.formatter);
        this.setLoggers(options.loggers);
    }
    setLevel(level) {
        if (level == null)
            level = constants_1.LogLevel.INFO;
        this.options.level = level;
        this.knownLoggers.clear();
    }
    setFormatter(formatter) {
        // Reset to default formatter if null or undefined is given
        if (formatter == null) {
            delete this.options.formatter;
            return;
        }
        // Check instance
        if (!(formatter instanceof formatter_1.Formatter))
            throw new Error('Invalid formatter');
        this.options.formatter = formatter;
    }
    setLoggers(loggers) {
        // Deep clone loggers so no further changes can be made
        if (Array.isArray(loggers)) {
            loggers = JSON.parse(JSON.stringify(loggers));
        }
        else {
            loggers = [];
        }
        this.options.loggers = loggers;
        this.knownLoggers.clear();
    }
    getAllowedLevel(logger) {
        if (this.knownLoggers.has(logger))
            return this.knownLoggers.get(logger);
        let allowLevel = constants_1.LogLevelValue[this.options.level];
        const identifier = `${logger.packageName}:${logger.packagePath}${logger.name}`;
        for (const log of this.options.loggers) {
            if (log.exact && identifier !== log.name)
                continue;
            if (!log.exact && !identifier.startsWith(log.name))
                continue;
            if (log.level === constants_1.LogLevel.OFF) {
                allowLevel = constants_1.LogLevelValue.OFF;
                break;
            }
            allowLevel = constants_1.LogLevelValue[log.level];
            break;
        }
        this.knownLoggers.set(logger, allowLevel);
        return allowLevel;
    }
    // tslint:disable-next-line:max-params
    log(origin, level, input, uniqueMarker, extra) {
        const allowLevel = this.getAllowedLevel(origin);
        if (allowLevel === constants_1.LogLevelValue.OFF || level === constants_1.LogLevel.OFF)
            return null;
        if (constants_1.LogLevelValue[level] > allowLevel)
            return null;
        if (typeof input === 'function')
            input = input();
        const meta = {
            origin,
            level,
            uniqueMarker,
            input,
            extra,
        };
        this.formatAndPrint(meta);
        return meta;
    }
    logMeta(meta) {
        const allowLevel = this.getAllowedLevel(meta.origin);
        if (allowLevel === constants_1.LogLevelValue.OFF || meta.level === constants_1.LogLevel.OFF)
            return;
        this.formatAndPrint(meta);
    }
    formatAndPrint(meta) {
        let message;
        if (this.options.formatter != null) {
            message = this.options.formatter.format(meta);
        }
        else {
            message = config_1.Config.getInstance().formatter.format(meta);
        }
        this.print(meta, message);
    }
}
exports.Transport = Transport;
//# sourceMappingURL=Transport.js.map