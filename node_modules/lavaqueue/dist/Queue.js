"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
class Queue extends events_1.EventEmitter {
    constructor(store, guildID) {
        super();
        this.store = store;
        this.guildID = guildID;
        this.keys = {
            next: `playlists.${this.guildID}.next`,
            pos: `playlists.${this.guildID}.pos`,
            prev: `playlists.${this.guildID}.prev`,
        };
        this.on('event', async (d) => {
            // if the track wasn't replaced or manually stopped, continue playing the next song
            if (d.type !== 'TrackEndEvent' || !['REPLACED', 'STOPPED'].includes(d.reason)) {
                let count = d.type === 'TrackEndEvent' ? undefined : 1;
                try {
                    await this._next({ count, previous: d });
                }
                catch (e) {
                    this.store.client.emit('error', e);
                }
            }
        });
        this.on('playerUpdate', async (d) => {
            try {
                await this._redis.set(this.keys.pos, d.state.position);
            }
            catch (e) {
                this.store.client.emit('error', e);
            }
        });
    }
    get player() {
        return this.store.client.players.get(this.guildID);
    }
    async start() {
        const np = await this.current();
        if (!np)
            return this._next();
        await this.player.play(np.track, { start: np.position });
        return true;
    }
    add(...tracks) {
        if (!tracks.length)
            return Promise.resolve(0);
        return this._redis.lpush(this.keys.next, ...tracks);
    }
    unshift(...tracks) {
        if (!tracks.length)
            return Promise.resolve(0);
        return this._redis.rpush(this.keys.next, ...tracks);
    }
    remove(track) {
        return this._redis.lrem(this.keys.next, 1, track);
    }
    next(count = 1) {
        return this._next({ count });
    }
    length() {
        return this._redis.llen(this.keys.next);
    }
    async sort(predicate) {
        const tracks = await this.tracks();
        tracks.sort(predicate);
        return this._redis.loverride(this.keys.next, ...tracks);
    }
    async move(from, to) {
        const list = await this._redis.lmove(this.keys.next, -from - 1, -to - 1); // work from the end of the list, since it's reversed
        return list.reverse();
    }
    shuffle() {
        return this._redis.lshuffle(this.keys.next, Date.now());
    }
    splice(start, deleteCount, ...tracks) {
        return this._redis.lrevsplice(this.keys.next, start, deleteCount, ...tracks);
    }
    trim(start, end) {
        return this._redis.ltrim(this.keys.next, start, end);
    }
    async stop() {
        await this.player.stop();
    }
    async clear() {
        return this._redis.del(this.keys.next, this.keys.prev, this.keys.pos);
    }
    async current() {
        const [track, position] = await Promise.all([
            this._redis.lindex(this.keys.prev, 0),
            this._redis.get(this.keys.pos),
        ]);
        if (track) {
            return {
                track,
                position: parseInt(position) || 0,
            };
        }
        return null;
    }
    async tracks(start = 0, end = -1) {
        if (end === Infinity)
            end = -1;
        const tracks = await this._redis.lrange(this.keys.next, start, end);
        return tracks.reverse();
    }
    async _next({ count, previous } = {}) {
        await this._redis.set(this.keys.pos, 0);
        if (!previous)
            previous = await this.current();
        if (count === undefined && previous) {
            const length = await this.length();
            count = this.store.client.advanceBy(this, { previous: previous.track, remaining: length });
        }
        if (count === 0)
            return this.start();
        const skipped = await this._redis.multirpoplpush(this.keys.next, this.keys.prev, count || 1);
        if (skipped.length)
            return this.start();
        await this.clear(); // we're at the end of the queue, so clear everything out
        return false;
    }
    get _redis() {
        return this.store.redis;
    }
}
exports.default = Queue;

//# sourceMappingURL=Queue.js.map
