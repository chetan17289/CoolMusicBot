{"version":3,"sources":["QueueStore.ts"],"names":[],"mappings":";;AAAA,mCAA4B;AAG5B,6BAA8B;AAC9B,yBAA0B;AAC1B,yCAAkC;AAUlC,MAAqB,UAAW,SAAQ,GAAkB;IAGxD,YAA4B,MAAc,EAAE,KAAkB;QAC5D,KAAK,EAAE,CAAC;QADkB,WAAM,GAAN,MAAM,CAAQ;QAGxC,IAAI,CAAC,KAAK,GAAG,KAAY,CAAC;QAE1B,KAAK,MAAM,OAAO,IAAI,kBAAQ,EAAE;YAC9B,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,EAAE;gBACrC,YAAY,EAAE,OAAO,CAAC,IAAI;gBAC1B,GAAG,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE;aAC3F,CAAC,CAAC;SACJ;IACH,CAAC;IAEM,GAAG,CAAC,GAAW;QACpB,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC3B,IAAI,CAAC,KAAK,EAAE;YACV,KAAK,GAAG,IAAI,eAAK,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YAC7B,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SACtB;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,KAAK,CAAC,MAAqC;QACtD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;QAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAC5B,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;YAC7C,IAAI,KAAK;gBAAE,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;QAEH,MAAM,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACnC,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC;gBAAE,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,CAAC;YAC7D,OAAO,KAAK,CAAC;QACf,CAAC,CAAC,CAAC,CAAC;IACN,CAAC;IAES,KAAK,CAAC,KAAK,CAAC,OAAe,EAAE,SAAiB,CAAC,EAAE,OAAiB,EAAE;QAC5E,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QACjE,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAE1B,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG;YAAE,OAAO,IAAI,CAAC;QACrC,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAChD,CAAC;CACF;AA/CD,6BA+CC","file":"QueueStore.js","sourcesContent":["import Queue from './Queue';\nimport Client from './';\nimport Redis = require('ioredis');\nimport path = require('path');\nimport fs = require('fs');\nimport commands from './commands';\n\nexport interface ExtendedRedis extends Redis.Redis {\n  lmove: (key: string, from: number, to: number) => Promise<string[]>;\n  loverride: (key: string, ...args: any[]) => Promise<number>;\n  lrevsplice: (key: string, start: number, deleteCount?: number, ...args: any[]) => Promise<string[]>;\n  lshuffle: (key: string, seed: number) => Promise<string[]>;\n  multirpoplpush: (source: string, dest: string, count: number) => Promise<string[]>;\n}\n\nexport default class QueueStore extends Map<string, Queue> {\n  public redis: ExtendedRedis;\n\n  constructor(public readonly client: Client, redis: Redis.Redis) {\n    super();\n\n    this.redis = redis as any;\n\n    for (const command of commands) {\n      this.redis.defineCommand(command.name, {\n        numberOfKeys: command.keys,\n        lua: fs.readFileSync(path.resolve(__dirname, 'scripts', `${command.name}.lua`)).toString(),\n      });\n    }\n  }\n\n  public get(key: string): Queue {\n    let queue = super.get(key);\n    if (!queue) {\n      queue = new Queue(this, key);\n      this.set(key, queue);\n    }\n\n    return queue;\n  }\n\n  public async start(filter?: (guildID: string) => boolean) {\n    const keys = await this._scan('playlists.*');\n    const guilds = keys.map(key => {\n      const match = key.match(/^playlists\\.(\\d+)/);\n      if (match) return match[1];\n      throw new Error('error extracting guild ID from playlist');\n    });\n\n    await Promise.all(guilds.map(guild => {\n      if (!filter || filter(guild)) return this.get(guild).start();\n      return false;\n    }));\n  }\n\n  protected async _scan(pattern: string, cursor: number = 0, keys: string[] = []): Promise<string[]> {\n    const response = await this.redis.scan(cursor, 'MATCH', pattern);\n    keys.push(...response[1]);\n\n    if (response[0] === '0') return keys;\n    return this._scan(pattern, response[0], keys);\n  }\n}\n"],"sourceRoot":"../src"}